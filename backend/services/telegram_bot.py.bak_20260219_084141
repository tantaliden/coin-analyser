#!/usr/bin/env python3
"""
Analyser Health-Bot - Der fleiÃŸige Kumpel
- Telegram-Befehle lesen & verarbeiten
- Health-Checks durchfÃ¼hren
- Heartbeat schreiben (beweist: ich lebe!)
- Watchdog-Service Ã¼berwachen
"""
import urllib.request
import urllib.parse
import json
import subprocess
import os
import time
import hashlib
from datetime import datetime
import pytz
import psycopg2

BERLIN_TZ = pytz.timezone('Europe/Berlin')

BOT_TOKEN = '8430890812:AAFAbxXkc9-hw19FMuaRQwN4d6s0O8rULrM'
CHAT_ID = '2112844328'

PASSWORD_FILE = '/opt/coin/backend/services/.bot_password'
SESSION_FILE = '/opt/coin/backend/services/.bot_session'
LOCKOUT_FILE = '/opt/coin/backend/services/.bot_lockout'
HEARTBEAT_FILE = '/opt/coin/logs/.health_heartbeat'
LOG_FILE = '/opt/coin/logs/telegram_bot.log'
ALERT_STATE_FILE = '/opt/coin/logs/.alert_sent'

SESSION_TIMEOUT = 3600
MAX_ATTEMPTS = 3
LOCKOUT_MINUTES = 5
HEALTH_CHECK_INTERVAL = 300  # 5 Minuten
HEARTBEAT_WRITE_INTERVAL = 60  # Heartbeat alle 60 Sek wenn Telegram OK

# Health Thresholds
METRICS_WARNING_MIN = 10
METRICS_CRITICAL_MIN = 30
CPU_WARNING = 80
RAM_WARNING = 85
DISK_WARNING = 85

# DB Config laden
with open('/opt/coin/database/settings.json') as f:
    SETTINGS = json.load(f)

DB_CONFIG = {
    'host': SETTINGS['databases']['coins']['host'],
    'port': SETTINGS['databases']['coins']['port'],
    'dbname': SETTINGS['databases']['coins']['name'],
    'user': SETTINGS['ingestor']['database']['user'],
    'password': SETTINGS['ingestor']['database']['password']
}

def log(msg):
    timestamp = datetime.now(BERLIN_TZ).strftime('%Y-%m-%d %H:%M:%S')
    line = f"[{timestamp}] {msg}"
    print(line, flush=True)
    try:
        with open(LOG_FILE, 'a') as f:
            f.write(line + '\n')
    except:
        pass

def write_heartbeat():
    """Heartbeat schreiben - beweist Watchdog dass wir leben"""
    try:
        with open(HEARTBEAT_FILE, 'w') as f:
            f.write(datetime.now(BERLIN_TZ).isoformat())
    except:
        pass

def hash_password(pw):
    return hashlib.sha256(pw.encode()).hexdigest()

def get_password():
    try:
        with open(PASSWORD_FILE, 'r') as f:
            return f.read().strip()
    except:
        save_password('1234')
        return hash_password('1234')

def save_password(new_pw):
    with open(PASSWORD_FILE, 'w') as f:
        f.write(hash_password(new_pw))
    os.chmod(PASSWORD_FILE, 0o600)

def is_locked_out():
    try:
        if os.path.exists(LOCKOUT_FILE):
            with open(LOCKOUT_FILE, 'r') as f:
                data = json.load(f)
            if data.get('attempts', 0) >= MAX_ATTEMPTS:
                elapsed = time.time() - data.get('time', 0)
                if elapsed < LOCKOUT_MINUTES * 60:
                    return True, int((LOCKOUT_MINUTES * 60 - elapsed) / 60) + 1
                else:
                    clear_lockout()
    except:
        pass
    return False, 0

def add_failed_attempt():
    try:
        data = {'attempts': 0, 'time': time.time()}
        if os.path.exists(LOCKOUT_FILE):
            with open(LOCKOUT_FILE, 'r') as f:
                data = json.load(f)
        data['attempts'] = data.get('attempts', 0) + 1
        data['time'] = time.time()
        with open(LOCKOUT_FILE, 'w') as f:
            json.dump(data, f)
        return data['attempts']
    except:
        return 0

def clear_lockout():
    try:
        if os.path.exists(LOCKOUT_FILE):
            os.remove(LOCKOUT_FILE)
    except:
        pass

def is_authenticated(chat_id):
    try:
        with open(SESSION_FILE, 'r') as f:
            data = json.load(f)
            if data.get('chat_id') == chat_id:
                if time.time() - data.get('time', 0) < SESSION_TIMEOUT:
                    return True
    except:
        pass
    return False

def set_authenticated(chat_id):
    with open(SESSION_FILE, 'w') as f:
        json.dump({'chat_id': chat_id, 'time': time.time()}, f)
    os.chmod(SESSION_FILE, 0o600)

def send_message(text):
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        data = urllib.parse.urlencode({
            'chat_id': CHAT_ID,
            'text': text,
            'parse_mode': 'HTML'
        }).encode('utf-8')
        req = urllib.request.Request(url, data=data)
        with urllib.request.urlopen(req, timeout=10) as response:
            return True
    except Exception as e:
        log(f"Send error: {e}")
        return False

def get_updates(offset=None):
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/getUpdates?timeout=30"
        if offset:
            url += f"&offset={offset}"
        req = urllib.request.Request(url)
        with urllib.request.urlopen(req, timeout=35) as response:
            data = json.loads(response.read().decode('utf-8'))
            return data.get('result', [])
    except Exception as e:
        log(f"GetUpdates error: {e}")
        time.sleep(5)
        return None  # None = Fehler, [] = keine Nachrichten

def run_command(cmd, timeout=30):
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
        return result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return "â± Timeout!"
    except Exception as e:
        return f"Fehler: {e}"

# ============ HEALTH CHECKS ============

def check_service(name):
    try:
        result = subprocess.run(['systemctl', 'is-active', name], capture_output=True, text=True, timeout=5)
        return result.stdout.strip() == 'active'
    except:
        return False

def check_kline_metrics():
    try:
        conn = psycopg2.connect(**DB_CONFIG, connect_timeout=10)
        conn.set_session(autocommit=True)
        with conn.cursor() as cur:
            cur.execute("SET statement_timeout = '10s'")
            cur.execute("SELECT MAX(open_time) FROM kline_metrics")
            result = cur.fetchone()
        conn.close()
        
        if result[0] is None:
            return 'CRITICAL', 'Keine Daten!'
        
        last_data = result[0]
        if last_data.tzinfo is None:
            last_data = BERLIN_TZ.localize(last_data)
        
        age_minutes = (datetime.now(BERLIN_TZ) - last_data).total_seconds() / 60
        
        if age_minutes > METRICS_CRITICAL_MIN:
            return 'CRITICAL', f'{age_minutes:.0f} min alt!'
        elif age_minutes > METRICS_WARNING_MIN:
            return 'WARNING', f'{age_minutes:.0f} min alt'
        return 'OK', f'{age_minutes:.0f} min'
    except Exception as e:
        return 'CRITICAL', f'DB: {e}'

def check_cpu():
    try:
        with open('/proc/loadavg', 'r') as f:
            load = float(f.read().split()[0])
        cpu_count = os.cpu_count() or 1
        pct = (load / cpu_count) * 100
        if pct > CPU_WARNING:
            return 'WARNING', f'CPU {pct:.0f}%'
        return 'OK', f'CPU {pct:.0f}%'
    except:
        return 'OK', 'CPU ?'

def check_ram():
    try:
        with open('/proc/meminfo', 'r') as f:
            lines = f.readlines()
        mem = {}
        for line in lines:
            parts = line.split()
            if len(parts) >= 2:
                mem[parts[0].rstrip(':')] = int(parts[1])
        total = mem.get('MemTotal', 1)
        available = mem.get('MemAvailable', 0)
        pct = ((total - available) / total) * 100
        if pct > RAM_WARNING:
            return 'WARNING', f'RAM {pct:.0f}%'
        return 'OK', f'RAM {pct:.0f}%'
    except:
        return 'OK', 'RAM ?'

def check_disk():
    try:
        result = subprocess.run(['df', '-h', '/'], capture_output=True, text=True, timeout=5)
        lines = result.stdout.strip().split('\n')
        if len(lines) >= 2:
            parts = lines[1].split()
            pct = int(parts[4].rstrip('%'))
            if pct > DISK_WARNING:
                return 'WARNING', f'SSD {pct}%'
            return 'OK', f'SSD {pct}%'
    except:
        pass
    return 'OK', 'SSD ?'

def check_watchdog_service():
    """PrÃ¼ft ob Watchdog-Service lÃ¤uft, startet ihn ggf. neu"""
    if not check_service('heartbeat-watchdog.service'):
        log("Watchdog-Service tot, starte neu...")
        subprocess.run(['systemctl', 'restart', 'heartbeat-watchdog.service'], timeout=30)
        return False
    return True

def should_send_alert():
    try:
        if os.path.exists(ALERT_STATE_FILE):
            mtime = os.path.getmtime(ALERT_STATE_FILE)
            if (time.time() - mtime) / 60 < 30:
                return False
    except:
        pass
    return True

def mark_alert_sent():
    with open(ALERT_STATE_FILE, 'w') as f:
        f.write(datetime.now().isoformat())

def clear_alert_state():
    try:
        if os.path.exists(ALERT_STATE_FILE):
            os.remove(ALERT_STATE_FILE)
    except:
        pass

def run_health_check():
    """FÃ¼hrt kompletten Health-Check durch"""
    log("=== Health Check ===")
    
    problems = []
    
    # Service Check
    if not check_service('kline-metrics-live.service'):
        problems.append("Service: kline-metrics-live DOWN!")
    if not check_service('analyser-ingestor.service'):
        problems.append("Service: analyser-ingestor DOWN!")
    
    # Metrics Check
    status, msg = check_kline_metrics()
    if status != 'OK':
        problems.append(f"Metrics: {msg}")
    
    # Server Checks
    status, msg = check_cpu()
    if status != 'OK':
        problems.append(msg)
    
    status, msg = check_ram()
    if status != 'OK':
        problems.append(msg)
    
    status, msg = check_disk()
    if status != 'OK':
        problems.append(msg)
    
    # Watchdog prÃ¼fen
    check_watchdog_service()
    
    if problems:
        log(f"Problems: {problems}")
        if should_send_alert():
            emoji = "ğŸš¨" if any('CRITICAL' in p or 'DOWN' in p for p in problems) else "âš ï¸"
            send_message(f"{emoji} <b>HEALTH ALERT</b>\n\n" + "\n".join(problems) + f"\n\nğŸ• {datetime.now(BERLIN_TZ).strftime('%H:%M')}")
            mark_alert_sent()
    else:
        if os.path.exists(ALERT_STATE_FILE):
            send_message(f"âœ… <b>HEALTH OK</b>\n\nAlles wieder normal.\n\nğŸ• {datetime.now(BERLIN_TZ).strftime('%H:%M')}")
        clear_alert_state()
        log("Health OK")

# ============ TELEGRAM COMMANDS ============

def cmd_help():
    return """ğŸ¤– <b>Analyser Bot</b>

<b>Ohne Login:</b>
help - Hilfe
login [pw]

<b>Nach Login:</b>
status - System-Status
health - Health-Check jetzt
metrics - Metrics Coverage (24h)
backfill - Backfill auslÃ¶sen
logs - Letzte Logs
logs - Letzte Logs
restart - Services neustarten
logout
changepw [alt] [neu]

â± Session: 1h | ğŸ”’ 3 Versuche"""

def cmd_status():
    output = run_command('/opt/coin/database/status.sh', timeout=15)
    if len(output) > 3500:
        output = output[:3500] + "\n..."
    return f"<pre>{output}</pre>"

def cmd_health():
    """Manueller Health-Check"""
    lines = []
    
    # Services
    services = ['kline-metrics-live', 'analyser-ingestor', 'heartbeat-watchdog', 'analyser-telegram-bot']
    for svc in services:
        ok = check_service(f'{svc}.service')
        emoji = "âœ…" if ok else "âŒ"
        lines.append(f"{emoji} {svc}")
    
    # Metrics
    status, msg = check_kline_metrics()
    emoji = "âœ…" if status == 'OK' else "âš ï¸" if status == 'WARNING' else "âŒ"
    lines.append(f"{emoji} Metrics: {msg}")
    
    # Server
    _, msg = check_cpu()
    lines.append(f"ğŸ’» {msg}")
    _, msg = check_ram()
    lines.append(f"ğŸ’» {msg}")
    _, msg = check_disk()
    lines.append(f"ğŸ’» {msg}")
    
    return "ğŸ¥ <b>Health Check</b>\n\n" + "\n".join(lines)

def cmd_metrics():
    """Zeigt Metrics Coverage fÃ¼r die letzten 24h"""
    try:
        conn = psycopg2.connect(**DB_CONFIG, connect_timeout=10)
        conn.set_session(autocommit=True)
        with conn.cursor() as cur:
            cur.execute("SET statement_timeout = '15s'")
            # Gesamt Zeilen vs befÃ¼llte in letzten 24h
            cur.execute("""
                SELECT COUNT(*) as total,
                       COUNT(pct_120m) as filled,
                       COUNT(*) - COUNT(pct_120m) as gaps
                FROM kline_metrics
                WHERE open_time >= NOW() - INTERVAL '24 hours'
            """)
            total, filled, gaps = cur.fetchone()
            
            pct = (filled / total * 100) if total > 0 else 0
            
            # Top 5 Symbole mit meisten LÃ¼cken
            cur.execute("""
                SELECT symbol, COUNT(*) as gap_count
                FROM kline_metrics
                WHERE open_time >= NOW() - INTERVAL '24 hours'
                  AND pct_120m IS NULL
                GROUP BY symbol
                ORDER BY COUNT(*) DESC LIMIT 5
            """)
            top_gaps = cur.fetchall()
        conn.close()
        
        emoji = "âœ…" if pct >= 99 else "âš ï¸" if pct >= 90 else "âŒ"
        lines = [f"{emoji} <b>Metrics Coverage (24h)</b>", ""]
        lines.append(f"Total: {total:,} Zeilen")
        lines.append(f"BefÃ¼llt: {filled:,} ({pct:.1f}%)")
        lines.append(f"LÃ¼cken: {gaps:,}")
        
        if top_gaps:
            lines.append("")
            lines.append("<b>Top LÃ¼cken:</b>")
            for sym, cnt in top_gaps:
                lines.append(f"  {sym}: {cnt}")
        
        return "\n".join(lines)
    except Exception as e:
        return f"âŒ Fehler: {e}"

def cmd_backfill():
    """LÃ¶st manuell einen Gap-Check + Backfill aus"""
    ps = run_command("pgrep -f 'kline_metrics_live' > /dev/null && echo 'RUNNING' || echo 'NOT'")
    if 'NOT' in ps:
        return "âŒ kline-metrics-live Service lÃ¤uft nicht!"
    
    # Signal an den Service senden: Gap-State-File lÃ¶schen um sofortigen Check auszulÃ¶sen
    run_command("rm -f /opt/coin/database/logs/.metrics_gap_state")
    run_command("systemctl restart kline-metrics-live.service")
    return "ğŸ”„ <b>Backfill ausgelÃ¶st</b>\n\nService wird neu gestartet.\nBeim Start: 2000min Lookback + sofortiger Gap-Check.\n\nCheck mit: metrics"

def cmd_logs():
    logs = run_command("tail -15 /opt/coin/database/logs/kline_metrics_live.log 2>/dev/null")
    return f"ğŸ“‹ <b>Logs</b>\n\n<pre>{logs[-3000:]}</pre>" if logs.strip() else "â„¹ï¸ Keine Logs"

def cmd_restart():
    send_message("ğŸ”„ <b>Restart...</b>")
    run_command("systemctl restart kline-metrics-live.service", timeout=30)
    time.sleep(3)
    run_command("systemctl restart analyser-ingestor.service", timeout=30)
    time.sleep(3)
    s1 = run_command("systemctl is-active kline-metrics-live.service").strip()
    s2 = run_command("systemctl is-active analyser-ingestor.service").strip()
    return f"âœ… <b>Restart fertig</b>\n\nmetrics: {s1}\ningestor: {s2}"

def handle_message(text, chat_id):
    text = text.strip()
    parts = text.split()
    cmd = parts[0].lower().lstrip('/') if parts else ""
    
    if str(chat_id) != CHAT_ID:
        return None
    
    if cmd in ('help', 'start', 'hilfe'):
        return cmd_help()
    
    if cmd == 'login':
        locked, remaining = is_locked_out()
        if locked:
            return f"ğŸ”’ Gesperrt! Noch {remaining} Min."
        
        if len(parts) < 2:
            return "âŒ login [passwort]"
        
        if hash_password(parts[1]) == get_password():
            set_authenticated(chat_id)
            clear_lockout()
            return "âœ… Eingeloggt!"
        else:
            attempts = add_failed_attempt()
            remaining = MAX_ATTEMPTS - attempts
            if remaining <= 0:
                return f"âŒ Falsch!\nğŸ”’ {LOCKOUT_MINUTES} Min Sperre!"
            return f"âŒ Falsch! Noch {remaining} Versuche."
    
    if not is_authenticated(chat_id):
        return "ğŸ”’ Erst: login [passwort]"
    
    if cmd == 'status':
        return cmd_status()
    elif cmd == 'health':
        return cmd_health()
    elif cmd == 'metrics':
        return cmd_metrics()
    elif cmd == 'backfill':
        return cmd_backfill()
    elif cmd == 'logs':
        return cmd_logs()
    elif cmd == 'restart':
        return cmd_restart()
    elif cmd == 'logout':
        try:
            os.remove(SESSION_FILE)
        except:
            pass
        return "ğŸ‘‹ Ausgeloggt!"
    elif cmd == 'changepw':
        if len(parts) < 3:
            return "âŒ changepw [alt] [neu]"
        if hash_password(parts[1]) == get_password():
            if len(parts[2]) < 4:
                return "âŒ Mind. 4 Zeichen!"
            save_password(parts[2])
            return "âœ… Passwort geÃ¤ndert!"
        return "âŒ Altes Passwort falsch!"
    
    return "â“ Unbekannt. help"

# ============ MAIN LOOP ============

def main():
    log("=== Health-Bot gestartet ===")
    send_message("ğŸ¤– <b>Health-Bot gestartet</b>\n\nPasswort: 1234")
    
    offset = None
    last_health_check = 0
    last_heartbeat = 0
    telegram_ok = True
    
    while True:
        try:
            now = time.time()
            
            # Telegram Updates holen
            updates = get_updates(offset)
            
            if updates is None:
                # Telegram-Fehler
                telegram_ok = False
            else:
                # Telegram funktioniert
                telegram_ok = True
                
                for update in updates:
                    offset = update['update_id'] + 1
                    if 'message' in update:
                        msg = update['message']
                        chat_id = msg['chat']['id']
                        text = msg.get('text', '')
                        if text:
                            log(f"Msg: {text[:50]}")
                            response = handle_message(text, chat_id)
                            if response:
                                send_message(response)
            
            # Heartbeat schreiben wenn Telegram OK (alle 60 Sek)
            if telegram_ok and (now - last_heartbeat >= HEARTBEAT_WRITE_INTERVAL):
                write_heartbeat()
                last_heartbeat = now
            
            # Health-Check alle 5 Minuten
            if now - last_health_check >= HEALTH_CHECK_INTERVAL:
                run_health_check()
                last_health_check = now
            
        except KeyboardInterrupt:
            break
        except Exception as e:
            log(f"Error: {e}")
            time.sleep(10)

if __name__ == '__main__':
    main()
